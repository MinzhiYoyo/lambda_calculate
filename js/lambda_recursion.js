/**
 * 实现 递归（迭代） recursion 的功能，递归和迭代在功能上是一样的
 */

var Y = g => (h=>h(h))(f => g(f(f))); // 递归函数 Y

var test = () =>{
	console.log("test");
}; 

// 定义递归函数（即 Y 算子），对于任意函数 G 来说，Y(G) 都是 G 的不动点
// 即 Y(G) -> G(Y(G)) -> G(G(Y(G))) -> ...
// 因此实现了递归，下面来一步一步定义 Y 算子，也是一步一步解耦业务的写法
// 使用斐波那契数列作为例子，斐波那契数列的定义如下：
var FIB = n => n==1?1:n*(FIB(n-1));  // 这里在函数体用到了 fib 函数名，不满足匿名函数的原则
console.log("原函数 FIB(5) = " + FIB(5)); // 120

// 值得注意的是，函数本身其实只有 `n => n==1?1:n*FIB(n-1)` 这一串东西

// 1. 匿名化函数，即把函数名当作参数传入即可
// 		注意在 fib1 的定义中没有 fib1 这个函数名了，便是匿名化成功
// 		不用在意后面调用的 fib1，这只是懒得把 fib1 整个函数重写一遍而已，就像下面
//		( f=>n=>n==1?1:n*(f(n-1)) ) ( f=>n=>n==1?1:n*(f(n-1)) ) (5)
var fib1 = f=>n=>n==1?1:n*(f(n-1));
console.log("fib1(fib1)(5) = " + fib1(fib1)(5)); // NAN

// 2. 上一步返回 NaN，显然有问题，那么问题出在哪呢？
// 		我们来看看 fib1(fib1)(2) 的调用过程就知道了：
// 		1. fib1(fib1)(2) 等价于
// 			 ( f=>n=>n==1?1:n*(f(n-1)) ) ( g=>x=>x==1?1:x*(g(x-1)) ) (2)
// 		-->	 (    n=>n==1?1:n*( ( g=>x=>x==1?1:x*(g(x-1)) ) (n-1) ) ) (2)
//		-->  (       2==1?1:2*( ( g=>x=>x==1?1:x*(g(x-1)) ) (2-1) ) ) 
//		-->	 (	            2*( ( g=>x=>x==1?1:x*(g(x-1)) ) (1)   ) )
//      -->  (              2*( (    x=>x==1?1:x*(1(x-1)) )       ) )
// 	    -->                                   1(x-1) 没有任何定义，所以这里是错误的
//		2. 如果是直接 fib1(fib1)(1) 的话: 是会直接等于1的
// 			 ( f=>n=>n==1?1:n*f(n-1) ) ( g=>x=>x==1?1:x*g(x-1) ) (2)
// 		-->	      n=>n==1?1:n*(g=>x=>x==1?1:x*g(x-1))(n-1) (2)
//		-->		     1==1?1:2*(g=>x=>x==1?1:x*g(x-1))(1-1)
//		-->		          1
var fib2 = f=>n=>n==1?1:n*(f(f)(n-1)); // 可以看出，这里的 fib2 就是一个独立的函数了，即完全实现匿名化了，因此可以把看作任意的函数 G
console.log("fib2(fib2)(5) = " + fib2(fib2)(5)); // 120，使用参数传入，120
// 		我们来看看 fib2(fib2)(m) 的调用过程就知道了：
// 		1. fib2(fib2)(m) 等价于：（注意，不妨使用一个符号 h 表示 fib2 即 `g=>x=>x==1?1:x*(g(g)(x-1))` 这一坨东西 ）
// 			 ( f=>n=>n==1?1:n*(  f(f)(n-1)) ) ( g=>x=>x==1?1:x*(g(g)(x-1)) ) (m)
//		-->	 (    n=>n==1?1:n*(  h(h)(n-1)  ) (m)
//		-->  (       m==1?1:m*(  h(h)(m-1)) )
//		-->	 (	            m*(  h(h)(m-1)  ) )
// 		-->  (              m*(  斐波m-1的值 ) )

/**
 * g=>x=>x==1?1:x*(g(g)(x-1)) 需要抽象出来，我们不能更改这个函数，主要是抽象出 g(g)
 * 
 * g=> (d=>x=>x==1?1:x*(d(x-1))) ( g(g) ) |  `d=>x=>x==1?1:x*(d(x-1))` 就是完整的业务函数了
 * 
 * 把业务函数剥离出来
 * 
 * (f => g => f (g(g)) ) (  `d=>x=>x==1?1:x*(d(x-1))` ) 传入了业务函数，但是没传入参数，不会执行的
 * 
 * 修复了 fib1 的问题之后，仍然需要使用 fib1 (fib1) (5) 才能进行递归，因此，再把两个 fib1 提取出来
 * 
 * ( h=>h(h) ) (
 * 		(f => g => f (g(g)) ) (  `d=>x=>x==1?1:x*(d(x-1))` )
 * )(5); // 这才是调用
 * 
 * 剥离业务函数和业务参数
 * e => (h=>h(h))(
 * 		(f => g => f (g(g)) ) (  e )
 * )
 * 
 * 注意内层 e=>(h=>h(h))(	...  )  省略号处可以先运行
 * 
 * e => (h => h(h))(
 * 		 g => e (g(g)) 
 * )
 * 
 * g=>e(g(g)) 这个 g 是独立的，所以可以直接写成 h，可能看到更明白一点
 * 
 * e => (h => h(h))(
 * 		h=>e(h(h))
 * )
 * --->
 * e => (h=>e(h(h))) (h=>e(h(h)))  // 这个就是 Y 算子了，而且对一般的函数都是用，后面的只能对递归函数使用 比如后面的 Y0 等等
 * 
*/



// 3. 简化一下，我们看到  ( f=>n=>n==1?1:n*(  f(f)(n-1)) ) ( g=>x=>x==1?1:x*(g(g)(x-1)) ) (m) 中
//	  明显前两个括号的东西重复了，不妨把他当成参数传入，它本身其实就是一个独立的函数，比如函数 G
//    G => (G)(G)(m) 这样的形式，当然这里的 G 还是 fib2 的定义
var fib3 = G=>m=>G(G)(m);  // 不妨尝试把 fib2 当前它的参数传入
console.log("fib3(fib2)(5) = " + fib3(fib2)(5)); // 120，使用参数传入，120


// 4. 这里 fib2 可以看作匿名化的函数 G，并且已经解耦了一部分了
//    但是 fib3 就是我们需要的 Y 吗？
//    当然不是，fib3 只是一个函数而已，它的参数是 G 和 m


// 5. 开始真正解耦了，回到下面的例子，明确业务函数是 `g=>x=>x==1?1:x*(g(g)(x-1))`，业务参数是 m
//     ( f=>n=>n==1?1:n*(f(f)(n-1))  ) ( g=>x=>x==1?1:x*(g(g)(x-1)) ) (m)
//    对于上述来说，可以看到 形如`g(g)` 的部分有两个，一个是小方面的 g(g)，一个是大方面的 fib2(fib2)
//    这两个其实就是递归的基本形式，毕竟递归就是同一个函数调用同一个函数
//    不妨定义一个新的函数， r = f=>f(f),上面就可以写作
// 	  r(fib2)(5)
var r = f=>f(f); // 递归函数
console.log("r(fib2)(5) = " + r(fib2)(5)); // 120，使用参数传入，120
// 虽然 r 和 fib3 调用形式都一样，但是最大的区别在于， r只有一个参数，fib3 有两个参数
// fib3是没有脱离业务的，所以 r 其实就可以看作我们的 Y 算子了

// 6. 开始真正的匿名化，抛弃 y
console.log("fib(5) = " + 
	( f=>f(f) )										 // Y算子
		(g => x => x == 1 ? 1 : x * (g(g)(x - 1)) )  // 业务函数
		(5)											 // 业务参数
);

// 7. 去掉业务参数和业务函数，那么就是 Y 算子了
var Y1 = g => (f => f(f)) (g);
console.log("Y1(fib2)(5) = " + Y1(fib2)(5)); // 120，使用参数传入，120


// 8. 不妨简单演算一遍 Y1 G
// 		1. Y1 G = (g => (f => f(f)) (g)) (G)
//		2. Y1 G = ( f => f(f) ) (G)  
//      3. Y1 G = G(G)  // 递归戛然而止了，如果 G 不是一个递归函数的话，那么就无法实现真正的递归了
//    发现最终 Y 没有了，那么其实只是执行了两遍业务函数而已，所以 Y1 还并不是我们需要的 Y 算子

// 9. Y0，
// var Y0 = f=>f(f); // 发现这个其实跟 Y1 的跟能很像啊，完全就没必要用到 Y1 ，Y0就可以了
var Y0 = f=>v=>f(f);
// Y0 是会栈溢出的，因为js会自动去调用它，所以我们把它改成不会调用的形式： Y0 = f=>v=>f(f)，也就是告诉js，在 v 这里停止就行，但是这个v其实没什么用的，后面需要改掉
// 回到最初的需求，需要使得 YG => G(YG) => G(G(YG)) => ...
// 然后我们 Y0 可以使得 Y0 G => G G
// 所以需要改造一下

// 10. Y2
var Y2 = g => (f => g(f(f))) (f => g(f(f)));


